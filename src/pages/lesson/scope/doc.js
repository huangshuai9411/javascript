import { reference  } from '@/util';

const docString1 = `
#### **什么是作用域**

在前面的章节学习中，我们已经初步接触到了作用域的内容，只是没有刻意去揭开作用域的本质。
我们已经知道，除了函数，其他变量都有先声明后使用的规则，这也符合我们对代码执行顺序的直观感受。
例如正确的代码：
> ${reference('let a = 1;')}

> ${reference('a++;')}

而不能这样写：

> ${reference('a++;')}

> ${reference('let a = 1;')}

或者可以这样

> ${reference('let b = 1;')}

> ${reference('if (condition) { b--; }')}，${reference('function () { b--; }')}

而不能这样：

> ${reference('if (condition) { let c = 1; }')}，${reference('function () { let c = 1; }')}

> ${reference('c++;')}

在变量声明时所在的**语句块内以及子块**（简单地讲就是被花括号包裹）内，可以访问到这个变量。而离开了这个块，变量就不能被访问到。最简单的判断**块**的方式就是观察是否有花括号“{}”的隔离。这是 ES6 以来模块化最为重要的特性之一，当然最初使用的 var 关键字声明变量并不遵循块作用域的规则，所以诟病较多，本教程在关键字一节就决定摒弃 var 关键字的使用，直接推动大家学习最新的更为完善的特性。关于**函数作用域**也是服从这样的特性，所以不再单独讲述。

> 回到顶部的代码，变量 a 的声明并没有在哪个**块**内，是否属于全局变量呢？我们可以这样理解，变量 a 在当前的代码文件内部可以处处（声明语句之后）访问到，在其他文件不能访问，等效于整个文件的代码在一个“隐形”的花括号内。这其实是模块的内容，欲深入了解可以在学习**流行框架**时加以关注。

循其本，作用域是可访问变量的集合。之所以能访问变量 b ，是因为在 ${reference('if 、 function')} 语句块内，b 变量还存在于内存中；而访问不到 c 变量，是因为访问的时候已经离开了声明时的语句块，变量 c 内存已经被回收。如果是下面这样呢？

> ${reference('let d = 1;')} // 语句1

> ${reference('if (true) { let d = 2; d = d + 1; console.log(d); // 语句2}')}

> ${reference('console.log(d);')} // 语句3

这个示例可以让我们更加了解**块级作用域**的工作方式。在语句 2 中访问变量 d，发现语句2内有 d 的声明，所以 ${reference('d = d + 1')} 是对语句2内的变量进行修改，第一次打印值为 3。语句3执行时，语句2内的所有变量已经不复存在，所以语句3访问到的 d 是语句1声明的那一个，因此打印 1。我们继续探讨：

> ${reference('let d = 1;')} // 语句1

> ${reference('if (true) { d = d + 1; console.log(d); // 语句2}')}

> ${reference('console.log(d);')} // 语句3

这一次，语句2中没有声明变量 d，根据作用域的规则，它将向上继续访问 if 块上面的变量d 并对 d 加 1。所以这两次打印的值均为2。如果向上一直没有找到变量 d 的声明，将抛出错误。

> 我们学习的内容均限定在严格模式下，非严格模式下代码的运行有不一致的行为，且严格模式编写代码是 JavaScript 大势所趋。至于非严格模式，有兴趣可自行了解，不推荐使用。


#### **什么是闭包**

按照作用域的规则，离开作用域后的变量我们是无法访问的，因为往往变量已经被垃圾机制回收。什么情况下不会被回收呢？就是该变量还在被使用的时候。当函数执行完毕，函数内声明的变量也会一并被销毁，这是再正常不过的情形。但有一种情况不会，这就形成了闭包(closure)。例如：
`;

const closure = `
function outer() {
  let count = 0;
  return function inner() {
    count++;
    return count;
  }
}

let closure = outer();
`;

const docString2 = `
上面的 outer 函数返回值还是一个函数，所以 closure 相当于内部的 inner 函数，是可以再次调用的。我们根据之前块作用域的理解， count 变量在执行完 outer 时就该被销毁了，但是 closure 引用的 inner 函数内，还存在着变量 count 的引用！所以我们调用 closure 时，还会一直返回 count 变量。

> ${reference('closure()')}; // 1

> ${reference('closure()')}; // 2

> ${reference('closure()')}; // 3

这就是闭包。闭包的内容暂时不多展开，到真正运用时，我们再来回顾。
`;

export default {
  docString1,
  docString2,
  closure,
}